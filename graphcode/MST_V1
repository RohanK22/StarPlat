function Boruvka (Graph g)
{
    // We need to provide id & color(component #) for each node in the graph.
    propNode<int> nodeId;
    propNode<int> color;
    
    g.attachNodeProperty(nodeId = -1);
    g.attachNodeProperty(color = -1);
    forall(dummy in g.nodes()){
        int i = 0;
        for(v in g.nodes()){
            v.nodeId = i;
            v.color = i;
            i = i + 1;
        } // TODO: This bracket is missing in the generated code.
    }
    
    // TODO: While loop should begin here
    propNode<bool> new_color_changes;
    g.attachNodeProperty(new_color_changes = False);

    bool no_new_comp = False;
    fixedPoint until (no_new_comp : !new_color_changes) {
        // 1a. Find min edge per vertex - O(n) per thread
        propNode<int> minedge_dst;
        propNode<int> minedge_wt;
        g.attachNodeProperty(minedge_dst=0);
        g.attachNodeProperty(minedge_wt=0);
        forall(src in g.nodes())
        {
            int min_weight = INF;
            int min_dst = V; // TODO: What is the right way to do this? Instead of hard coding V
            
            for(dst in g.neighbors(src))
            {
                edge e = g.get_edge(dummy, dummy);
                int wt = e.weight;
                if(dst.color != src.color && (min_dst == V || wt < min_weight || (wt == min_weight && dst.color < min_dst.color))){
                    min_weight = wt;
                    min_dst = dst;
                }
            }
            src.minedge_dst = min_dst;
            src.minedge_wt = min_weight;
        }
        
        // 1b. Find min edge per connected component - O(n) per thread
        propNode<int> minedge_cc_dst;
        g.attachNodeProperty(minedge_cc_dst=0);
        forall(src in g.nodes())
        {
            if(src.color == src.nodeId){
                int min_weight = INF;
                int min_dst = V; // TODO: What is the right way to do this? Instead of hard coding V
                
                for(nbr in g.nodes().filter(color == src.color))
                {
                    int dst = nbr.minedge_dst;
                    int wt = nbr.minedge_wt;
                    if(dst != V){
                        if(min_dst == V || wt < min_weight || (wt == min_weight && dst.color < min_dst.color)){
                            min_weight = wt;
                            min_dst = dst;
                        }
                    }
                }

                if(min_dst == V) {src.minedge_cc_dst = V;}
                else {src.minedge_cc_dst = min_dst.color;}
            }
        }

        // 2. Remove mirrored edges
        forall(src in g.nodes())
        {
            if(src.color == src.nodeId){
                // edge1 - (src1, dst1)
                // edge2 - (dst1, dst2)
                int dst1 = src1.minedge_cc_dst;
                if(dst1 != V)
                {
                    int dst2 = dst1.minedge_cc_dst;
                    if(dst2 != V)
                    {
                        if(src1.color == dst2.color && src1.color > dst1.color)
                        {
                            dst1.minedge_cc_dst = V;
                        }
                    }
                }
            }
        }

        // 3. Collecting MST edges

        // 4a. Propagating colors to only union-leaders
        propNode<bool> modified;
        g.attachNodeProperty(modified = False);
        bool finished = False;
        fixedPoint until (finished: !modified) {
            forall(u in g.nodes()) {
                if(u.color == u.nodeId){
                    int min_edge_dst = u.minedge_cc_dst;
                    if(min_edge_dst != V) {
                        u.color = min_edge_dst.color;
                        u.modified = True;
                        u.new_color_changes = True;
                    }
                }
            }
        }

        // 4b. Propagating colors to all other nodes thru leaders
        forall(u in g.nodes()) {
            int lead = u.color;
            if(lead.color != u.color) {
                u.color = lead.color;
                u.modified = True;
                // u.new_color_changes = True; // TODO : do we need this operation here?
            }
        }
    }   
}