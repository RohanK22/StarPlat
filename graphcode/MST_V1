function Boruvka (Graph g)
{
    // We need to provide id & color(component #) for each node in the graph.
    propNode<int> nodeId;
    propNode<int> color;
    propEdge<bool> isMSTEdge;
    
    g.attachNodeProperty(nodeId = -1);
    g.attachNodeProperty(color = -1);
    g.attachEdgeProperty(isMSTEdge = False);
    
    // Initialize the graph with each node in its own component.
    forall(dummy in g.nodes()){
        int i = 0;
        for(v in g.nodes()){
            v.nodeId = i;
            v.color = i;
            i = i + 1;
        }
    }
    
    propNode<bool> newColorChanges;
    g.attachNodeProperty(newColorChanges = False);

    bool noNewComp = False;
    fixedPoint until (noNewComp : !newColorChanges) {
        // 1a. Find min edge per vertex - O(n) per thread
        propNode<int> minEdge; // TODO: Should be replaced by edge, int is just a hack
        g.attachNodeProperty(minEdge=-1);
        forall(src in g.nodes())
        {   
            for(dst in g.neighbors(src))
            {
                edge e = g.get_edge(dummy, dummy);
                edge minEdge = src.minEdge;
                node minDst = minEdge.data;
                if(dst.color != src.color && (minEdge == -1 || e.weight < minEdge.weight || (e.weight == minEdge.weight && dst.color < minDst.color))){
                    src.minEdge = e;
                }
            }
        }
        
        // 1b. Find min edge per connected component - O(n) per thread
        propNode<int> minEdgeOfComp;
        g.attachNodeProperty(minEdgeOfComp=0);
        forall(src in g.nodes())
        {
            if(src.color == src.nodeId){
                
                for(nbr in g.nodes().filter(color == src.color))
                {
                    edge minEdgeNbr = nbr.minEdge;
                    edge minEdgeOfComp = src.minEdgeOfComp;
                    node minDst = minEdgeOfComp.data;
                    node dst = minEdgeNbr.data;
                    if(minEdgeNbr != -1){
                        if(minEdgeOfComp == -1 || minEdgeNbr.weight < minEdgeOfComp.weight || (minEdgeNbr.weight == minEdgeOfComp.weight && dst.color < minDst.color)){
                            src.minEdgeOfComp = minEdgeNbr;
                        }
                    }
                }
                
                edge minEdgeOfComp = src.minEdgeOfComp;
                if(minEdgeOfComp != -1){
                    minEdgeOfComp.isMSTEdge = True;
                }
            }
        }

        // 2. Remove mirrored edges
        forall(src in g.nodes())
        {
            if(src.color == src.nodeId){
                edge srcMinEdge = src.minEdgeOfComp;
                if(srcMinEdge != -1)
                {
                    node dst = srcMinEdge.data; 
                    node dstLead = dst.color;
                    edge dstMinEdge = dstLead.minEdgeOfComp;
                    if(dstMinEdge != -1)
                    {
                        node dstOfDst = dstMinEdge.data;
                        if(src.color == dstOfDst.color && src.color > dst.color)
                        {
                            dstLead.minEdgeOfComp = -1;
                        }
                    }
                }
            }
        }

        // 3a. Propagating colors to only union-leaders
        propNode<bool> modified;
        g.attachNodeProperty(modified = False);
        bool finished = False;
        fixedPoint until (finished: !modified) {
            forall(u in g.nodes()) {
                if(u.color == u.nodeId){
                    edge minEdgeOfComp = u.minEdgeOfComp;
                    if(minEdgeOfComp != -1) {
                        node minDstLead = minEdgeOfComp.data;
                        u.color = minDst.color;
                        u.modified = True;
                        u.newColorChanges = True;
                    }
                }
            }
        }

        // 3b. Propagating colors to all other nodes thru leaders
        forall(u in g.nodes()) {
            int lead = u.color;
            if(lead.color != u.color) {
                u.color = lead.color;
                u.modified = True;
            }
        }
    }   
}