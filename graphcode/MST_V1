function Boruvka (Graph g_orig)
{
// propNode <bool> modified;
// g.attachNodeProperty(dist=INF, modified = False);
// src.modified = True; 
// src.dist=0;
// bool finished =False;
// fixedPoint until (finished:!modified)
// {
// forall (v in g.nodes().filter(modified == True) )
// {
//      forall (nbr in g.neighbors(v))
//                         {          
//                         edge e = g.get_edge(v, nbr);
//                         <nbr.dist,nbr.modified> = <Min (nbr.dist, v.dist + e.weight), True>;
//                         }
// }
// }          

    Graph g = duplicate(g_orig);
    propEdge<int> weight;
    propEdge<int> mst_edges;
    g.attachEdgeProperty(weight=0);
    g.attachEdgeProperty(mst_edges=0);
    
    // 1. Find min edge per vertex
    propNode<edge> minedge;
    g.attachNodeProperty(minedge=-1);

    forall(u in g.nodes())
	{
        edge min_edge;
        unsigned min_weight = UINT_MAX; // TODO: What's the constant?
        unsigned min_dst = g.numNodes();
        for(e in g.edges_from(u))
        {
            unsigned wt = e.weight;
            unsigned dst = g.get_destination(e);
            // TODO: How to compare 2 nodes (dst_id < min_dst_id)?
            if(wt < min_weight || (wt == min_weight && dst.nodeId < min_dst.nodeId))
            {
                min_weight = wt;
                min_edge = e;
                min_dst = dst;
            }
        }
        u.minedge = min_edge;
	}
    
    // 2. Remove mirrored edges
    forall(src1 in g.nodes())
    {
        edge edge1 = src1.minedge;
        // edge1 - (src1, dst1)
        // edge2 - (dst1, dst2)
        if(edge1 != nil) // TODO: What's the constant for nil?
        {
            node dst1 = g.get_destination(edge1);
            edge edge2 = dst1.minedge;
            if(edge2 != nil)
            {
                node dst2 = g.get_destination(edge2);
                // TODO: How does this work?
                if(src1.nodeId == dst2.nodeId && src1.nodeId > dst1.nodeId)
                {
                    dst1.minedge = nil;
                }
            }
        }
    }
    
    // Between step
    // We need to collect MST EDGES 
    forall(u in g.nodes()) {
        edge edg = u.minedge;
        if(edg != nil) {
            mst_edges[edg] = 1; // TODO : is it correct way to do this?
        }
    }

    // 3. Intialise colours
    propNode<int> color;
    g.attachNodeProperty(color=-1);
    forall(u in g.nodes())
    {
        edge edg = u.minedge;
        if(edg == nil) u.color = u.nodeId;
        else u.color = g.get_destination(edg).nodeId;
    }
    
    // 4. Propagate colours
    propNode <bool> modified;
    g.attachNodeProperty(modified = False);
    fixedPoint until (finished: !modified)
    {
        forall(u in g.nodes())
        {
            edge edg = u.minedge;
            if(edg != nil)
            {
                node dst = g.get_destination(edg);
                if(u.color != dst.color)
                {
                    u.color = dst.color;
                    u.modified = True;
                }
            }
        }
    }
    
    // 5. Creating new id's for vertices
    propNode<int> super_node;
    g.attachNodeProperty(super_node=0);
    forall(u in g.nodes())
    {   
        if(u.color == u.nodeId && g.out_degree(u) > 0)
        {
            u.super_node = 1;
        }
    }

    // 6. Perform prefix sum on new_id .. so that u.new_id represents super vertex new id
    propNode <bool> modified;
    g.attachNodeProperty(modified = False);
    propNode<int> new_id;
    g.attachNodeProperty(new_id=0);
    fixedPoint until (finished: !modified)
    {
        forall(u in g.nodes())
        {
            int prev_node_id = u.nodeId - 1;
            node prev_node = g.getNode(prev_node_id);
            <u.new_id, u.modified> = <max (u.new_id, prev_node.new_id + u.super_node), True>;
        }
    }

    Graph new_g;
    // 7. Adding nodes into new graph
    forall(u in g.nodes()) {
        if(u.nodeId == u.color) {
            new_g.add_node(u.new_id);
        }
    }

    // 8. Adding new edges into new graph
    forall(u in g.nodes()) {
        int super_vertex_id = (u.color).new_id;
        forall(dst in g.neighbors(u))  {
            // TODO : what is g.nnodes?
            if(dst != g.nnodes) {
                if(dst.color != u.color) {
                    edge e = g.get_edge(u, dst);
                    int wei = e.weight;
                    new_g.add_edge(u.color, dst.color);
                    // TODO : how to add edges weights to this new graph?
                }
            }
        }
    }

    // 10. Using new graph for next step
    g = new_g;
     
}