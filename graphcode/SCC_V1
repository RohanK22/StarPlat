// Algorithm : Hone et al algorithm 
// The core algorithm of Forward and Backward, works as follows :
// The lowest id, non-scc vertex (non-scc vertex is the vertex whose scc is not yet computed) propagates its id.
// Vertices "src" with src (vertex id) == src.scc, represent leaders of SCC components. This property used to count no.of SCCs.
function Hong (Graph g)
{
    propNode<int> modified;
    propNode<int> scc;
    g.attachNodeProperty(modified = False, scc = -1);
    
    //1. Trim Function
    bool fpoint1 = False;
    fixedPoint until (fpoint1 : !modified) {
        forall(src in g.nodes().filter(scc == -1)) {
            int ifIn = 0; int ifOut = 0;
            for(dst in g.nodes_to(src).filter(scc == -1)) {ifIn = 1;}
            for(dst in g.neighbors(src).filter(scc == -1)) {ifOut = 1;}
            if((ifIn == 0) || (ifOut == 0)) {
                src.scc = src;
                fpoint1 = False;
            }
        }
    }

    propNode<int> visitFw; 
    propNode<int> visitBw; 
    g.attachNodeProperty(visitFw = -1, visitBw = -1);

    //3. Till we can find new pivot
    bool fpoint2 = False;
    fixedPoint until (fpoint2: !modified) {
        // Initializing visitFw, visitBw attributes with vertex ids.
        forall(src in g.nodes().filter(scc == -1)) {
            src.visitFw = src;
            src.visitBw = src;
        }
        

        // FW-BW Reach (until reachability closure found)
        bool fpoint3 = False;
        fixedPoint until (fpoint3 : !modified) {
            // Forward
            forall(src in g.nodes().filter(scc == -1)) {
                for(dst in g.neighbors(src).filter(scc == -1)) {
                    // src pass its visitFw number to its destination vertex dst under following condition
                    if(dst.visitFw > src.visitFw) {
                        dst.visitFw = src.visitFw;
                        fpoint3 = False;
                    } 
                }
            }

            // Backward
            forall(src in g.nodes().filter(scc == -1)) {
                for(dst in g.nodes_to(src).filter(scc == -1)) {
                    if(dst.visitBw > src.visitBw) {
                        dst.visitBw = src.visitBw;
                        fpoint3 = False;
                    } 
                }
            }
        }

        //8. Update SCC
        forall(v in g.nodes().filter(scc == -1)) {
            if(v.visitFw == v.visitBw) {
                v.scc = v.visitFw;
                fpoint2 = False;
            }
        }

        //6. TRIM 
        fpoint1 = False;
        fixedPoint until (fpoint1 : !modified) {
            forall(src in g.nodes().filter(scc == -1)) {
                int ifIn = 0; int ifOut = 0;
                for(dst in g.nodes_to(src).filter(scc == -1)) {ifIn = 1;}
                for(dst in g.neighbors(src).filter(scc == -1)) {ifOut = 1;}
                if((ifIn == 0) || (ifOut == 0)) {
                    src.scc = src;
                    fpoint1 = False;
                }
            }
        }
    }

}


