Static staticTC(Graph g)
{
  long triangle_count = 0;
  
  forall(v in g.nodes())
   {
      forall(u in g.neighbors(v).filter(u < v))
         {
           forall(w in g.neighbors(v).filter(w > v))
             {
                 if(g.is_an_edge(u,w))
                   {
                    triangle_count+=1;
                   }
             }

         } 
   }

   return triangle_count ;

}

incremental(Graph g, int triangle_countSent, propEdge<bool> modified)
{

 long triangle_count = triangle_countSent;
 int count1 = 0;
 int count2 = 0;
 int count3 = 0;
  
 
 Update Processing:
    {
      int v1 = update.source;
      int v2 = update.destination;
      
      forall(v3 in g.neighbors(v1))
         {
           edge e1 = g.get_edge(v1, v3); 
            int newEdge = 1;
            bool isTriangle = False;


           if(e1.modified)
              newEdge = newEdge + 1;

           if(g.is_an_edge(v2, v3))
              {
                  edge e2 = g.get_edge(v2, v3); 
                  isTriangle = True;
                  if(e2.modified)
                      newEdge = newEdge + 1;
              }


         if(isTriangle)
          {
          if(newEdge == 1)
             { 
               count1 += 1;
             }
           else if(newEdge == 2)
               {
                 count2 += 1;   
               } 
           else
              {
                 count3 += 1;
              }   
           } 
             
      } 

  }

  triangle_count = triangle_count + (count1/2 + count2/4 + count3/6);

   return triangle_count ;

}


decremental(Graph g, int triangle_countSent, propEdge<bool> modified)
{
  long triangle_count = triangle_countSent;
 int count1 = 0;
 int count2 = 0;
 int count3 = 0;
  
  
 Update Processing:
     {
     
      int v1 = update.source;
      int v2 = update.destination;
      
      forall(v3 in g.neighbors(v1))
         {
           edge e1 = g.get_edge(v1, v3); 
           int newEdge = 1;
           bool isTriangle = False;


           if(e1.modified)
              newEdge = newEdge + 1;

           if(g.is_an_edge(v2, v3))
              {
                  edge e2 = g.get_edge(v2, v3); 
                  isTriangle = True;
                  if(e2.modified)
                      newEdge = newEdge + 1;
              }

          if(isTriangle)
            {
          if(newEdge == 1)
             { 
               count1 += 1;
             }
           else if(newEdge == 2)
               {
                 count2 += 1;   
               } 
           else
              {
                 count3 += 1;
              }   
           } 
             
         }       
   }

   return triangle_count ;
 

}

Dynamic DynTC(Graph g, list<update> updates)
{
  int triangleCount = staticTC(g);

  propNode<bool> modified_add;
  propNode<bool> modified_del;

  Batch{
     g.attachNodeProperty(modified_add = false,modified_del = false);

     Update Processing:
         deletion
          {
            int src = update.source;
            int dest = update.destination;

            for(nbr in g.neighbors(src))
               {
                 edge e = g.get_edge(src,nbr);
                 if(nbr == dest)
                  modified_del[e] = True;
               }
          }


     triangleCount = Decremental(g, triangleCount, modified_del);
     g.updateCSR_Del();

     g.updsteCSR_Add();

     Update Processing:
          addition
            {
               int src = update.source;
               int dest = update.destination;

               for(nbr in g.neighbors(src))
                  {
                    edge e = g.get_edge(src,nbr);
                    if(nbr == dest)
                       modified_add[e] = True;
                  }
             }  

       triangleCount = Incremental(g, triangleCount, modified_add);    

  }



  }


